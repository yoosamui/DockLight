#pragma once
#include <getopt.h>
#include <stdio.h>
#include "common.h"


#include <unistd.h>


DL_NS_BEGIN
namespace cli
{
    typedef struct {
        char arg = 0;
        char string_value[512];
        int int_value = 0;
        size_t size{0};

    } result_t;

    static result_t* _ptr = nullptr;
    static result_t* _itr = nullptr;
    static result_t _results[10];


    static  void add_item(const char arg,  char* cvalue, int ivalue){
     //   result_t* p = (result_t*)malloc(sizeof(result_t));
//        if(arrayPtr == nullptr){
        //    arrayPtr[nr] = (result_t*)malloc(sizeof(result_t));
  //      }

//        p = arrayPtr[0];
//
//
 //       #define BUFSIZE  112
       // char buf[BUFSIZE+1];
        //snprintf(buf,BUFSIZE,"%s",cvalue);

       // memcpy(p->string_value,cvalue,sizeof(cvalue) + 1 );
        memcpy(_itr->string_value,cvalue,sizeof(cvalue));
        _itr->arg = arg;
        _itr->int_value = ivalue;
        _ptr->size++;

        _itr++;


return;
    }
    class arguments
    {
        const char* short_opts = "h:m:c:p";

        public:
        explicit arguments(int argc, char** argv)
        {
            m_argc = argc;
            m_argv = argv;

          _itr = _ptr = _results;
        }

        result_t* validate()
        {
            // clang-format off
            const option long_opts[] = {
                {"help", optional_argument, nullptr, 'h'},
                {"monitor", required_argument, nullptr, 'm'},
                {"position", required_argument, nullptr, 'p'},
                {"config", required_argument, nullptr, 'c'},
                {NULL,0,NULL,0}
            };
            // clang-format on

            int error_code = EXIT_SUCCESS;
            int opt = 0;
            string config_file;

            try {
                while ((opt = getopt_long(m_argc, m_argv, short_opts, long_opts, nullptr)) != -1) {
                    if (parse(opt, optarg) == EXIT_FAILURE) {
                        goto error;
                        break;
                    }
                }

            } catch (const exception& err) {
                error_code = EXIT_FAILURE;
                g_print("PARAMETER ERROR: %s\n", err.what());
                goto help;
            }

            if (error_code == EXIT_SUCCESS) {
                return _ptr;
            }

            // clang-format off
error:
            g_print("INVALID PARAMETERS.\n");
            error_code = EXIT_FAILURE;

help:

            g_print("--------------------------------\n");
            g_print(" docklight arguments help.\n");
            g_print("--------------------------------\n");
            g_print("--h --help Display this help.\n");
            g_print("--p --position sets the position on the selected monitor (bottom, left ,top or right).\n");
            g_print("--c --config path to the configuration file.\n\n");

            return _ptr;
        };


        private:
        int m_argc;
        char** m_argv;

        int parse(int opt,  char* coptarg){

//            _addr = strdup(optarg);

            if (!coptarg || strlen(coptarg) == 0) {
                return EXIT_FAILURE;
            }




            if((char)opt == 'm')
                //return set_monitor(strdup(coptarg));
                return set_monitor(coptarg);


//            if((char)opt == 'p')
  //              return set_position(addr);


            return EXIT_SUCCESS;
        }

        int set_monitor( char* coptarg) {



           unsigned int value = atoi(coptarg);

           if (value == 0) {
                return EXIT_FAILURE;
            }

        //#define BUFSIZE  112
       // char buf[BUFSIZE+1];
       // snprintf(buf,BUFSIZE,"%s",coptarg);
           add_item('m',coptarg, value);

            return EXIT_SUCCESS;
        }

        int set_position(const char* optarg) {

            //add_item('p',optarg,0);

            return EXIT_SUCCESS;
        }

        //void add(const char arg, const char* cvalue, int ivalue){

            //_itr->arg = arg;
            //_itr->int_value = ivalue;
           //;
            //size_t size = sizeof(cvalue);
            //memcpy(_itr->string_value,  cvalue, size + 1);
            //_itr->string_value[511] = '\0';

            //_ptr->size++;
            //_itr++;
        //}

    };
}  // namespace cli
DL_NS_END

